
### 方法调用过程

#### C语言中的方法调用过程 

以下面代码为例

```
void test() {
    printf("hello");
}

void main() {
    test();
}
```

C语言使用的是**静态绑定**，也就是说在编译期就决定了执行时要调用的函数。

在上面例子中，`main`函数中调用了`test`方法。

那么，编译之后，假设`test`的函数实现在内存中的地址是0x0034，那么在`main`函数中调用`test`方法实际就是将0x0034这个地址直接硬编码在这里。执行的时候就是去这个地址去获取这个函数。

#### OC中的方法调用

OC中的方法调用采用的是**动态绑定**机制。也就是说，在编译期的时候不知道具体函数实现代码的位置。只有在运行时才根据方法名去寻找具体函数实现的位置。

在OC中当我们这样调用一个方法时 
```
[obj doSomething:params];
```

编译后会将其转换为如下的一个函数调用

```
objc_msgSend(obj, @selector(doSomething:), params);
```

这个函数中，第一个参数是调用者，第二个参数叫‘选择子’，其实就是方法名，后面的参数是方法中接收的参数。

**所以，OC中的方法调用也可以看做是像一个对象发送消息。**

当这个对象接收到一个消息之后，就会去它的类的方法列表中去找这个方法名对应的方法实现。

这里可以理解是，每个类有一个表，这个表是方法名和方法实现的地址对应表。通过方法名可以在这个表中查询到对应的方法实现的地址。

方法名 | 方法实现的地址
:---: | :---: 
doSomething | 0x0089

如果在这个方法列表中没有找到这个方法名，那么开始执行消息转发的流程。

**这里也就是OC动态绑定的实现，它在运行时才在这个方法表中根据方法名去查找方法的实现，所以，基于这个特点我们可以在运行时动态的改变方法名和方法实现的对应关系，实现动态改变方法执行，在运行时去添加方法，添加属性等等。**

### 消息转发流程

当一个对象接收到消息之后，根据自己的isa指针去类的方法列表中去查找是否有这个方法

如果当前类没有，根据类的isa指针去父类中查找，在整个继承体系中都没有找到这个方法。

开始执行下面的消息转发流程

1. 首先检查当前类，通过下面的方式检查是否可以添加这个未找到的方法。这一步叫做**动态方法解析**

    对象没有找到这个方法后，就会检查是否实现了下面的这个方法

    ```
    + (BOOL) resolveInstanceMethod:(SEL)selector
    ```

    在这个方法的实现中就可以通过`class_addMethod`动态的添加未实现的方法。

    这种方式的前提是方法的实现代码已经有了，但是没有和方法名关联起来。

    因为`class_addMethod`实际是将方法名和方法实现的地址进行了对应。

2. 第二步，备援接受者

    当在第一步没能处理这个消息，运行时系统会通过下面这个方法检查是否有其他对象可以处理这个方法。
    ```
    - (id) forwardingTargetForSelector:(SEL)selector
    ```
    当实现了这个方法，会返回一个可以处理这个方法的对象。

3. 最后一步， 消息转发

    当上面两个方法都没有做处理之后，就会检查是否实现了下面的方法，

    ```
    - (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector
    ```

    **如果这个方法没有实现、或者返回nil。则直接调用`NSObject`的`doesNotRecognizeSelector`方法抛出未找到方法的异常。流程结束**

    如果这个方法返回了一个有效的方法签名。就会去检查是否实现了下面的这个方法。

    ```
    - (void) forwardInvocation:(NSInvocation *)invocation
    ```

    这里就会创建一个`NSInvocation`对象。这时消息派发系统会将这个`NSInvocation`对象指派给目标对象

    这个`NSInvocation`对象中封装了和消息有关的全部内容，包括方法名、参数、调用者等。

    在这个方法的实现中可以改变调用者，使消息传递到新的调用者。这样操作和第二步有些雷同。区别在于可以将消息发给多个对象，而第二步只能返回一个对象。

    并且在这里可以改变消息内容，比如增加参数、改变方法名等。

    如果没有实现，则最终执行`NSObject`中的该方法，在`NSObject`中该方法的实现则是直接去调用`doesNotRecognizeSelector`抛出了未找到方法的异常。

#### 缓存方法

对于查找过的方法，会将方法地址与方法名进行缓存

当下次调用这个方法时，直接从缓存中获取方法地址，避免再次去查找过程。
