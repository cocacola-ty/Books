
### 屏幕的渲染过程

系统从帧缓冲区中取出来一帧图像交给显示器。

显示器从上到下逐行的进行显示，渲染玩一行内容之后，发出一个水平同步信号HSync，然后移动到下一行开始渲染

渲染到最后一行，这一帧图像渲染完成。

然后等系统发出一个垂直同步信号VSync的时候，开始下一帧图片的渲染。

VSync信号的发出是由显示器的刷新频率决定的。如显示器的刷新频率是60Hz，那么每秒就会发出60次VSync信号。

### 卡顿的产生

每发出一个VSync信号就开始新的一帧的渲染。

在这一帧图片渲染的时候，系统图像服务会通过CADisplayLink等机制通知APP，APP主线程开始在CPU中进行计算要显示的内容，比如视图的创建、布局的计算、图片的解码、文本的绘制等

CPU计算好之后将提交给GPU，GPU进行变换、合成、渲染

然后GPU将处理好的结果提交到帧缓冲区中。

下一个VSync信号来了之后，就从缓冲区中取这一帧去进行显示

但是，由于VSync的频率是固定的。在下一次VSync信号到来的时候如果没有完成这一系列的操作，没有将渲染结果放到帧缓冲区中。那么这一帧就被丢弃。显示器还显示上一帧的内容。这样造成的效果就是卡顿。从一帧图片跳跃到一帧图片。

### 卡顿的解决

从上面卡顿原因可以看到，无论是CPU还是GPU计算时间过长都会导致无法在一个VSYNCX信号期间完成渲染。所以要解决卡顿要减轻CPU和GPU的负担。

* CPU
    * 布局计算
    * autolayout

    Autolayout对于复杂视图来说会产生严重的性能问题。autolayout的约束最终都是转换为对应的坐标点。而这个转换过程是一个解n元一次线性方程组的过程，随着视图越复杂这个计算量就越大。

    * 文本计算

    如果一个界面包含大量文本，文本的宽高计算会占用很大一部分资源，并且不可避免。解决方法可以是通过`boundingRectWithSize:options:context`来计算文本宽高，用`[NSAttributedString drawWithRect:options:context]`来绘制文本。需要在子线程去执行，避免阻塞主线程。

    * 文本渲染

    屏幕上能看到的所有文本内容控件，底层都是通过`CoreText`排版，然后绘制为`Bitmap`显示的。常见的文本控件(`UILabel`、`UITextView`等)的排版和绘制都是在主线程进行的，当显示大量文本时，CPU的压力会非常大。解决方案只有通过自定义文本控件。用`TextKit`或最底层的`CoreText`对文本异步进行绘制。`CoreText`对象创建好厚，能直接获取文本的宽高等信息，避免了多次计算（调整UILabel大小时计算一编、UILabel绘制时内部再计算一遍）。

    * 图片解码

    当使用`UIImage`或`CGImageSource`的几个方法来创建图片时，**图片并不会立即解码**，图片设置到`UIImageView`或`CALayer.contents`中去，并且`CALayer`被提交到GPU前，`CGImage`中的数据才会得到解码。这一步是在主线程发生，并且不可避免。绕开这个机制的常见做法是在后台线程先把图片绘制到`CGBitmapContext`中，然后从`Bitmap`直接创建图片。

    * 图片的绘制

    图像的绘制通常是指用以`CG`开头的方法把图像绘制到画布中，然后从画布创建图片这样的过程。最常见的地方是在`drawRect:`方法中。解决方法：由于`CoreGraphics`方法通常都是线程安全的，所以图像的绘制可以放到后台线程中。

    * 对象创建
    * 对象调整
    * 对象销毁

* GPU 

    * 视图的混合

    当多个视图（或者CALayer）重叠在一起显示时，GPU会首先把他们混合在一起，如果视图结构过于复杂，混合的过程会消耗很多的GPU资源。为了减轻这种情况下的GPU消耗，应用应当适量减少视图数量和层次。

    在不透明的视图里标明`opaque`属性以避免无用的alpha通道合成。

    * 图形的合成

    `CALayer`的圆角、阴影、遮罩等通过会出发离屏渲染。

### 参考资料

https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/

